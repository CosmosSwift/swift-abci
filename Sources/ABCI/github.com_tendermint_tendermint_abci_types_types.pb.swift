// ===----------------------------------------------------------------------===
//
//  This source file is part of the CosmosSwift open source project.
//
//  github.com_tendermint_tendermint_abci_types_types.pb.swift last updated 02/06/2020
//
//  Copyright Â© 2020 Katalysis B.V. and the CosmosSwift project authors.
//  Licensed under Apache License v2.0
//
//  See LICENSE.txt for license information
//  See CONTRIBUTORS.txt for the list of CosmosSwift project authors
//
//  SPDX-License-Identifier: Apache-2.0
//
// ===----------------------------------------------------------------------===

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

struct Types_Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: OneOf_Value? {
        get { return _storage._value }
        set { _uniqueStorage()._value = newValue }
    }

    var echo: Types_RequestEcho {
        get {
            if case let .echo(v)? = _storage._value { return v }
            return Types_RequestEcho()
        }
        set { _uniqueStorage()._value = .echo(newValue) }
    }

    var flush: Types_RequestFlush {
        get {
            if case let .flush(v)? = _storage._value { return v }
            return Types_RequestFlush()
        }
        set { _uniqueStorage()._value = .flush(newValue) }
    }

    var info: Types_RequestInfo {
        get {
            if case let .info(v)? = _storage._value { return v }
            return Types_RequestInfo()
        }
        set { _uniqueStorage()._value = .info(newValue) }
    }

    var setOption: Types_RequestSetOption {
        get {
            if case let .setOption(v)? = _storage._value { return v }
            return Types_RequestSetOption()
        }
        set { _uniqueStorage()._value = .setOption(newValue) }
    }

    var initChain: Types_RequestInitChain {
        get {
            if case let .initChain(v)? = _storage._value { return v }
            return Types_RequestInitChain()
        }
        set { _uniqueStorage()._value = .initChain(newValue) }
    }

    var query: Types_RequestQuery {
        get {
            if case let .query(v)? = _storage._value { return v }
            return Types_RequestQuery()
        }
        set { _uniqueStorage()._value = .query(newValue) }
    }

    var beginBlock: Types_RequestBeginBlock {
        get {
            if case let .beginBlock(v)? = _storage._value { return v }
            return Types_RequestBeginBlock()
        }
        set { _uniqueStorage()._value = .beginBlock(newValue) }
    }

    var checkTx: Types_RequestCheckTx {
        get {
            if case let .checkTx(v)? = _storage._value { return v }
            return Types_RequestCheckTx()
        }
        set { _uniqueStorage()._value = .checkTx(newValue) }
    }

    var deliverTx: Types_RequestDeliverTx {
        get {
            if case let .deliverTx(v)? = _storage._value { return v }
            return Types_RequestDeliverTx()
        }
        set { _uniqueStorage()._value = .deliverTx(newValue) }
    }

    var endBlock: Types_RequestEndBlock {
        get {
            if case let .endBlock(v)? = _storage._value { return v }
            return Types_RequestEndBlock()
        }
        set { _uniqueStorage()._value = .endBlock(newValue) }
    }

    var commit: Types_RequestCommit {
        get {
            if case let .commit(v)? = _storage._value { return v }
            return Types_RequestCommit()
        }
        set { _uniqueStorage()._value = .commit(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Value: Equatable {
        case echo(Types_RequestEcho)
        case flush(Types_RequestFlush)
        case info(Types_RequestInfo)
        case setOption(Types_RequestSetOption)
        case initChain(Types_RequestInitChain)
        case query(Types_RequestQuery)
        case beginBlock(Types_RequestBeginBlock)
        case checkTx(Types_RequestCheckTx)
        case deliverTx(Types_RequestDeliverTx)
        case endBlock(Types_RequestEndBlock)
        case commit(Types_RequestCommit)

        #if !swift(>=4.1)
            static func == (lhs: Types_Request.OneOf_Value, rhs: Types_Request.OneOf_Value) -> Bool {
                switch (lhs, rhs) {
                case let (.echo(l), .echo(r)): return l == r
                case let (.flush(l), .flush(r)): return l == r
                case let (.info(l), .info(r)): return l == r
                case let (.setOption(l), .setOption(r)): return l == r
                case let (.initChain(l), .initChain(r)): return l == r
                case let (.query(l), .query(r)): return l == r
                case let (.beginBlock(l), .beginBlock(r)): return l == r
                case let (.checkTx(l), .checkTx(r)): return l == r
                case let (.deliverTx(l), .deliverTx(r)): return l == r
                case let (.endBlock(l), .endBlock(r)): return l == r
                case let (.commit(l), .commit(r)): return l == r
                default: return false
                }
            }
        #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_RequestEcho {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var message: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_RequestFlush {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_RequestInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var version: String = String()

    var blockVersion: UInt64 = 0

    var p2PVersion: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// nondeterministic
struct Types_RequestSetOption {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: String = String()

    var value: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_RequestInitChain {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var time: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _uniqueStorage()._time = newValue }
    }

    /// Returns true if `time` has been explicitly set.
    var hasTime: Bool { return _storage._time != nil }
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    mutating func clearTime() { _uniqueStorage()._time = nil }

    var chainID: String {
        get { return _storage._chainID }
        set { _uniqueStorage()._chainID = newValue }
    }

    var consensusParams: Types_ConsensusParams {
        get { return _storage._consensusParams ?? Types_ConsensusParams() }
        set { _uniqueStorage()._consensusParams = newValue }
    }

    /// Returns true if `consensusParams` has been explicitly set.
    var hasConsensusParams: Bool { return _storage._consensusParams != nil }
    /// Clears the value of `consensusParams`. Subsequent reads from it will return its default value.
    mutating func clearConsensusParams() { _uniqueStorage()._consensusParams = nil }

    var validators: [Types_ValidatorUpdate] {
        get { return _storage._validators }
        set { _uniqueStorage()._validators = newValue }
    }

    var appStateBytes: Data {
        get { return _storage._appStateBytes }
        set { _uniqueStorage()._appStateBytes = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_RequestQuery {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Data = SwiftProtobuf.Internal.emptyData

    var path: String = String()

    var height: Int64 = 0

    var prove: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_RequestBeginBlock {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hash: Data {
        get { return _storage._hash }
        set { _uniqueStorage()._hash = newValue }
    }

    var header: Types_Header {
        get { return _storage._header ?? Types_Header() }
        set { _uniqueStorage()._header = newValue }
    }

    /// Returns true if `header` has been explicitly set.
    var hasHeader: Bool { return _storage._header != nil }
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    mutating func clearHeader() { _uniqueStorage()._header = nil }

    var lastCommitInfo: Types_LastCommitInfo {
        get { return _storage._lastCommitInfo ?? Types_LastCommitInfo() }
        set { _uniqueStorage()._lastCommitInfo = newValue }
    }

    /// Returns true if `lastCommitInfo` has been explicitly set.
    var hasLastCommitInfo: Bool { return _storage._lastCommitInfo != nil }
    /// Clears the value of `lastCommitInfo`. Subsequent reads from it will return its default value.
    mutating func clearLastCommitInfo() { _uniqueStorage()._lastCommitInfo = nil }

    var byzantineValidators: [Types_Evidence] {
        get { return _storage._byzantineValidators }
        set { _uniqueStorage()._byzantineValidators = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_RequestCheckTx {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tx: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_RequestDeliverTx {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tx: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_RequestEndBlock {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var height: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_RequestCommit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: OneOf_Value? {
        get { return _storage._value }
        set { _uniqueStorage()._value = newValue }
    }

    var exception: Types_ResponseException {
        get {
            if case let .exception(v)? = _storage._value { return v }
            return Types_ResponseException()
        }
        set { _uniqueStorage()._value = .exception(newValue) }
    }

    var echo: Types_ResponseEcho {
        get {
            if case let .echo(v)? = _storage._value { return v }
            return Types_ResponseEcho()
        }
        set { _uniqueStorage()._value = .echo(newValue) }
    }

    var flush: Types_ResponseFlush {
        get {
            if case let .flush(v)? = _storage._value { return v }
            return Types_ResponseFlush()
        }
        set { _uniqueStorage()._value = .flush(newValue) }
    }

    var info: Types_ResponseInfo {
        get {
            if case let .info(v)? = _storage._value { return v }
            return Types_ResponseInfo()
        }
        set { _uniqueStorage()._value = .info(newValue) }
    }

    var setOption: Types_ResponseSetOption {
        get {
            if case let .setOption(v)? = _storage._value { return v }
            return Types_ResponseSetOption()
        }
        set { _uniqueStorage()._value = .setOption(newValue) }
    }

    var initChain: Types_ResponseInitChain {
        get {
            if case let .initChain(v)? = _storage._value { return v }
            return Types_ResponseInitChain()
        }
        set { _uniqueStorage()._value = .initChain(newValue) }
    }

    var query: Types_ResponseQuery {
        get {
            if case let .query(v)? = _storage._value { return v }
            return Types_ResponseQuery()
        }
        set { _uniqueStorage()._value = .query(newValue) }
    }

    var beginBlock: Types_ResponseBeginBlock {
        get {
            if case let .beginBlock(v)? = _storage._value { return v }
            return Types_ResponseBeginBlock()
        }
        set { _uniqueStorage()._value = .beginBlock(newValue) }
    }

    var checkTx: Types_ResponseCheckTx {
        get {
            if case let .checkTx(v)? = _storage._value { return v }
            return Types_ResponseCheckTx()
        }
        set { _uniqueStorage()._value = .checkTx(newValue) }
    }

    var deliverTx: Types_ResponseDeliverTx {
        get {
            if case let .deliverTx(v)? = _storage._value { return v }
            return Types_ResponseDeliverTx()
        }
        set { _uniqueStorage()._value = .deliverTx(newValue) }
    }

    var endBlock: Types_ResponseEndBlock {
        get {
            if case let .endBlock(v)? = _storage._value { return v }
            return Types_ResponseEndBlock()
        }
        set { _uniqueStorage()._value = .endBlock(newValue) }
    }

    var commit: Types_ResponseCommit {
        get {
            if case let .commit(v)? = _storage._value { return v }
            return Types_ResponseCommit()
        }
        set { _uniqueStorage()._value = .commit(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Value: Equatable {
        case exception(Types_ResponseException)
        case echo(Types_ResponseEcho)
        case flush(Types_ResponseFlush)
        case info(Types_ResponseInfo)
        case setOption(Types_ResponseSetOption)
        case initChain(Types_ResponseInitChain)
        case query(Types_ResponseQuery)
        case beginBlock(Types_ResponseBeginBlock)
        case checkTx(Types_ResponseCheckTx)
        case deliverTx(Types_ResponseDeliverTx)
        case endBlock(Types_ResponseEndBlock)
        case commit(Types_ResponseCommit)

        #if !swift(>=4.1)
            static func == (lhs: Types_Response.OneOf_Value, rhs: Types_Response.OneOf_Value) -> Bool {
                switch (lhs, rhs) {
                case let (.exception(l), .exception(r)): return l == r
                case let (.echo(l), .echo(r)): return l == r
                case let (.flush(l), .flush(r)): return l == r
                case let (.info(l), .info(r)): return l == r
                case let (.setOption(l), .setOption(r)): return l == r
                case let (.initChain(l), .initChain(r)): return l == r
                case let (.query(l), .query(r)): return l == r
                case let (.beginBlock(l), .beginBlock(r)): return l == r
                case let (.checkTx(l), .checkTx(r)): return l == r
                case let (.deliverTx(l), .deliverTx(r)): return l == r
                case let (.endBlock(l), .endBlock(r)): return l == r
                case let (.commit(l), .commit(r)): return l == r
                default: return false
                }
            }
        #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// nondeterministic
struct Types_ResponseException {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var error: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_ResponseEcho {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var message: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_ResponseFlush {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_ResponseInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: String = String()

    var version: String = String()

    var appVersion: UInt64 = 0

    var lastBlockHeight: Int64 = 0

    var lastBlockAppHash: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// nondeterministic
struct Types_ResponseSetOption {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: UInt32 = 0

    /// bytes data = 2;
    var log: String = String()

    var info: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_ResponseInitChain {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var consensusParams: Types_ConsensusParams {
        get { return _storage._consensusParams ?? Types_ConsensusParams() }
        set { _uniqueStorage()._consensusParams = newValue }
    }

    /// Returns true if `consensusParams` has been explicitly set.
    var hasConsensusParams: Bool { return _storage._consensusParams != nil }
    /// Clears the value of `consensusParams`. Subsequent reads from it will return its default value.
    mutating func clearConsensusParams() { _uniqueStorage()._consensusParams = nil }

    var validators: [Types_ValidatorUpdate] {
        get { return _storage._validators }
        set { _uniqueStorage()._validators = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_ResponseQuery {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: UInt32 {
        get { return _storage._code }
        set { _uniqueStorage()._code = newValue }
    }

    /// bytes data = 2; // use "value" instead.
    var log: String {
        get { return _storage._log }
        set { _uniqueStorage()._log = newValue }
    }

    /// nondeterministic
    var info: String {
        get { return _storage._info }
        set { _uniqueStorage()._info = newValue }
    }

    var index: Int64 {
        get { return _storage._index }
        set { _uniqueStorage()._index = newValue }
    }

    var key: Data {
        get { return _storage._key }
        set { _uniqueStorage()._key = newValue }
    }

    var value: Data {
        get { return _storage._value }
        set { _uniqueStorage()._value = newValue }
    }

    var proof: Merkle_Proof {
        get { return _storage._proof ?? Merkle_Proof() }
        set { _uniqueStorage()._proof = newValue }
    }

    /// Returns true if `proof` has been explicitly set.
    var hasProof: Bool { return _storage._proof != nil }
    /// Clears the value of `proof`. Subsequent reads from it will return its default value.
    mutating func clearProof() { _uniqueStorage()._proof = nil }

    var height: Int64 {
        get { return _storage._height }
        set { _uniqueStorage()._height = newValue }
    }

    var codespace: String {
        get { return _storage._codespace }
        set { _uniqueStorage()._codespace = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_ResponseBeginBlock {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var events: [Types_Event] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_ResponseCheckTx {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: UInt32 = 0

    var data: Data = SwiftProtobuf.Internal.emptyData

    /// nondeterministic
    var log: String = String()

    /// nondeterministic
    var info: String = String()

    var gasWanted: Int64 = 0

    var gasUsed: Int64 = 0

    var events: [Types_Event] = []

    var codespace: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_ResponseDeliverTx {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: UInt32 = 0

    var data: Data = SwiftProtobuf.Internal.emptyData

    /// nondeterministic
    var log: String = String()

    /// nondeterministic
    var info: String = String()

    var gasWanted: Int64 = 0

    var gasUsed: Int64 = 0

    var events: [Types_Event] = []

    var codespace: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_ResponseEndBlock {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var validatorUpdates: [Types_ValidatorUpdate] {
        get { return _storage._validatorUpdates }
        set { _uniqueStorage()._validatorUpdates = newValue }
    }

    var consensusParamUpdates: Types_ConsensusParams {
        get { return _storage._consensusParamUpdates ?? Types_ConsensusParams() }
        set { _uniqueStorage()._consensusParamUpdates = newValue }
    }

    /// Returns true if `consensusParamUpdates` has been explicitly set.
    var hasConsensusParamUpdates: Bool { return _storage._consensusParamUpdates != nil }
    /// Clears the value of `consensusParamUpdates`. Subsequent reads from it will return its default value.
    mutating func clearConsensusParamUpdates() { _uniqueStorage()._consensusParamUpdates = nil }

    var events: [Types_Event] {
        get { return _storage._events }
        set { _uniqueStorage()._events = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_ResponseCommit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// reserve 1
    var data: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// ConsensusParams contains all consensus-relevant parameters
/// that can be adjusted by the abci app
struct Types_ConsensusParams {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var block: Types_BlockParams {
        get { return _storage._block ?? Types_BlockParams() }
        set { _uniqueStorage()._block = newValue }
    }

    /// Returns true if `block` has been explicitly set.
    var hasBlock: Bool { return _storage._block != nil }
    /// Clears the value of `block`. Subsequent reads from it will return its default value.
    mutating func clearBlock() { _uniqueStorage()._block = nil }

    var evidence: Types_EvidenceParams {
        get { return _storage._evidence ?? Types_EvidenceParams() }
        set { _uniqueStorage()._evidence = newValue }
    }

    /// Returns true if `evidence` has been explicitly set.
    var hasEvidence: Bool { return _storage._evidence != nil }
    /// Clears the value of `evidence`. Subsequent reads from it will return its default value.
    mutating func clearEvidence() { _uniqueStorage()._evidence = nil }

    var validator: Types_ValidatorParams {
        get { return _storage._validator ?? Types_ValidatorParams() }
        set { _uniqueStorage()._validator = newValue }
    }

    /// Returns true if `validator` has been explicitly set.
    var hasValidator: Bool { return _storage._validator != nil }
    /// Clears the value of `validator`. Subsequent reads from it will return its default value.
    mutating func clearValidator() { _uniqueStorage()._validator = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// BlockParams contains limits on the block size.
struct Types_BlockParams {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Note: must be greater than 0
    var maxBytes: Int64 = 0

    /// Note: must be greater or equal to -1
    var maxGas: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// EvidenceParams contains limits on the evidence.
struct Types_EvidenceParams {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Note: must be greater than 0
    var maxAge: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// ValidatorParams contains limits on validators.
struct Types_ValidatorParams {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pubKeyTypes: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_LastCommitInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var round: Int32 = 0

    var votes: [Types_VoteInfo] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_Event {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: String = String()

    var attributes: [Common_KVPair] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_Header {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// basic block info
    var version: Types_Version {
        get { return _storage._version ?? Types_Version() }
        set { _uniqueStorage()._version = newValue }
    }

    /// Returns true if `version` has been explicitly set.
    var hasVersion: Bool { return _storage._version != nil }
    /// Clears the value of `version`. Subsequent reads from it will return its default value.
    mutating func clearVersion() { _uniqueStorage()._version = nil }

    var chainID: String {
        get { return _storage._chainID }
        set { _uniqueStorage()._chainID = newValue }
    }

    var height: Int64 {
        get { return _storage._height }
        set { _uniqueStorage()._height = newValue }
    }

    var time: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _uniqueStorage()._time = newValue }
    }

    /// Returns true if `time` has been explicitly set.
    var hasTime: Bool { return _storage._time != nil }
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    mutating func clearTime() { _uniqueStorage()._time = nil }

    var numTxs: Int64 {
        get { return _storage._numTxs }
        set { _uniqueStorage()._numTxs = newValue }
    }

    var totalTxs: Int64 {
        get { return _storage._totalTxs }
        set { _uniqueStorage()._totalTxs = newValue }
    }

    /// prev block info
    var lastBlockID: Types_BlockID {
        get { return _storage._lastBlockID ?? Types_BlockID() }
        set { _uniqueStorage()._lastBlockID = newValue }
    }

    /// Returns true if `lastBlockID` has been explicitly set.
    var hasLastBlockID: Bool { return _storage._lastBlockID != nil }
    /// Clears the value of `lastBlockID`. Subsequent reads from it will return its default value.
    mutating func clearLastBlockID() { _uniqueStorage()._lastBlockID = nil }

    /// hashes of block data
    var lastCommitHash: Data {
        get { return _storage._lastCommitHash }
        set { _uniqueStorage()._lastCommitHash = newValue }
    }

    /// transactions
    var dataHash: Data {
        get { return _storage._dataHash }
        set { _uniqueStorage()._dataHash = newValue }
    }

    /// hashes from the app output from the prev block
    var validatorsHash: Data {
        get { return _storage._validatorsHash }
        set { _uniqueStorage()._validatorsHash = newValue }
    }

    /// validators for the next block
    var nextValidatorsHash: Data {
        get { return _storage._nextValidatorsHash }
        set { _uniqueStorage()._nextValidatorsHash = newValue }
    }

    /// consensus params for current block
    var consensusHash: Data {
        get { return _storage._consensusHash }
        set { _uniqueStorage()._consensusHash = newValue }
    }

    /// state after txs from the previous block
    var appHash: Data {
        get { return _storage._appHash }
        set { _uniqueStorage()._appHash = newValue }
    }

    /// root hash of all results from the txs from the previous block
    var lastResultsHash: Data {
        get { return _storage._lastResultsHash }
        set { _uniqueStorage()._lastResultsHash = newValue }
    }

    /// consensus info
    var evidenceHash: Data {
        get { return _storage._evidenceHash }
        set { _uniqueStorage()._evidenceHash = newValue }
    }

    /// original proposer of the block
    var proposerAddress: Data {
        get { return _storage._proposerAddress }
        set { _uniqueStorage()._proposerAddress = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_Version {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var block: UInt64 = 0

    var app: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_BlockID {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hash: Data {
        get { return _storage._hash }
        set { _uniqueStorage()._hash = newValue }
    }

    var partsHeader: Types_PartSetHeader {
        get { return _storage._partsHeader ?? Types_PartSetHeader() }
        set { _uniqueStorage()._partsHeader = newValue }
    }

    /// Returns true if `partsHeader` has been explicitly set.
    var hasPartsHeader: Bool { return _storage._partsHeader != nil }
    /// Clears the value of `partsHeader`. Subsequent reads from it will return its default value.
    mutating func clearPartsHeader() { _uniqueStorage()._partsHeader = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_PartSetHeader {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var total: Int32 = 0

    var hash: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Validator
struct Types_Validator {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var address: Data = SwiftProtobuf.Internal.emptyData

    /// PubKey pub_key = 2 [(gogoproto.nullable)=false];
    var power: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// ValidatorUpdate
struct Types_ValidatorUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pubKey: Types_PubKey {
        get { return _storage._pubKey ?? Types_PubKey() }
        set { _uniqueStorage()._pubKey = newValue }
    }

    /// Returns true if `pubKey` has been explicitly set.
    var hasPubKey: Bool { return _storage._pubKey != nil }
    /// Clears the value of `pubKey`. Subsequent reads from it will return its default value.
    mutating func clearPubKey() { _uniqueStorage()._pubKey = nil }

    var power: Int64 {
        get { return _storage._power }
        set { _uniqueStorage()._power = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// VoteInfo
struct Types_VoteInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var validator: Types_Validator {
        get { return _storage._validator ?? Types_Validator() }
        set { _uniqueStorage()._validator = newValue }
    }

    /// Returns true if `validator` has been explicitly set.
    var hasValidator: Bool { return _storage._validator != nil }
    /// Clears the value of `validator`. Subsequent reads from it will return its default value.
    mutating func clearValidator() { _uniqueStorage()._validator = nil }

    var signedLastBlock: Bool {
        get { return _storage._signedLastBlock }
        set { _uniqueStorage()._signedLastBlock = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_PubKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: String = String()

    var data: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Types_Evidence {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: String {
        get { return _storage._type }
        set { _uniqueStorage()._type = newValue }
    }

    var validator: Types_Validator {
        get { return _storage._validator ?? Types_Validator() }
        set { _uniqueStorage()._validator = newValue }
    }

    /// Returns true if `validator` has been explicitly set.
    var hasValidator: Bool { return _storage._validator != nil }
    /// Clears the value of `validator`. Subsequent reads from it will return its default value.
    mutating func clearValidator() { _uniqueStorage()._validator = nil }

    var height: Int64 {
        get { return _storage._height }
        set { _uniqueStorage()._height = newValue }
    }

    var time: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _uniqueStorage()._time = newValue }
    }

    /// Returns true if `time` has been explicitly set.
    var hasTime: Bool { return _storage._time != nil }
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    mutating func clearTime() { _uniqueStorage()._time = nil }

    var totalVotingPower: Int64 {
        get { return _storage._totalVotingPower }
        set { _uniqueStorage()._totalVotingPower = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "types"

extension Types_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Request"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        2: .same(proto: "echo"),
        3: .same(proto: "flush"),
        4: .same(proto: "info"),
        5: .standard(proto: "set_option"),
        6: .standard(proto: "init_chain"),
        7: .same(proto: "query"),
        8: .standard(proto: "begin_block"),
        9: .standard(proto: "check_tx"),
        19: .standard(proto: "deliver_tx"),
        11: .standard(proto: "end_block"),
        12: .same(proto: "commit"),
    ]

    fileprivate class _StorageClass {
        var _value: Types_Request.OneOf_Value?

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _value = source._value
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 2:
                    var v: Types_RequestEcho?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .echo(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .echo(v) }
                case 3:
                    var v: Types_RequestFlush?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .flush(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .flush(v) }
                case 4:
                    var v: Types_RequestInfo?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .info(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .info(v) }
                case 5:
                    var v: Types_RequestSetOption?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .setOption(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .setOption(v) }
                case 6:
                    var v: Types_RequestInitChain?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .initChain(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .initChain(v) }
                case 7:
                    var v: Types_RequestQuery?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .query(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .query(v) }
                case 8:
                    var v: Types_RequestBeginBlock?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .beginBlock(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .beginBlock(v) }
                case 9:
                    var v: Types_RequestCheckTx?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .checkTx(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .checkTx(v) }
                case 11:
                    var v: Types_RequestEndBlock?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .endBlock(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .endBlock(v) }
                case 12:
                    var v: Types_RequestCommit?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .commit(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .commit(v) }
                case 19:
                    var v: Types_RequestDeliverTx?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .deliverTx(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .deliverTx(v) }
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            switch _storage._value {
            case let .echo(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            case let .flush(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            case let .info(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            case let .setOption(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            case let .initChain(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            case let .query(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            case let .beginBlock(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            case let .checkTx(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            case let .endBlock(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            case let .commit(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            case let .deliverTx(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_Request, rhs: Types_Request) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._value != rhs_storage._value { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_RequestEcho: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RequestEcho"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "message"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &message)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_RequestEcho, rhs: Types_RequestEcho) -> Bool {
        if lhs.message != rhs.message { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_RequestFlush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RequestFlush"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_RequestFlush, rhs: Types_RequestFlush) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_RequestInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RequestInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "version"),
        2: .standard(proto: "block_version"),
        3: .standard(proto: "p2p_version"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &version)
            case 2: try decoder.decodeSingularUInt64Field(value: &blockVersion)
            case 3: try decoder.decodeSingularUInt64Field(value: &p2PVersion)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !version.isEmpty {
            try visitor.visitSingularStringField(value: version, fieldNumber: 1)
        }
        if blockVersion != 0 {
            try visitor.visitSingularUInt64Field(value: blockVersion, fieldNumber: 2)
        }
        if p2PVersion != 0 {
            try visitor.visitSingularUInt64Field(value: p2PVersion, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_RequestInfo, rhs: Types_RequestInfo) -> Bool {
        if lhs.version != rhs.version { return false }
        if lhs.blockVersion != rhs.blockVersion { return false }
        if lhs.p2PVersion != rhs.p2PVersion { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_RequestSetOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RequestSetOption"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "key"),
        2: .same(proto: "value"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &key)
            case 2: try decoder.decodeSingularStringField(value: &value)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !key.isEmpty {
            try visitor.visitSingularStringField(value: key, fieldNumber: 1)
        }
        if !value.isEmpty {
            try visitor.visitSingularStringField(value: value, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_RequestSetOption, rhs: Types_RequestSetOption) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_RequestInitChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RequestInitChain"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "time"),
        2: .standard(proto: "chain_id"),
        3: .standard(proto: "consensus_params"),
        4: .same(proto: "validators"),
        5: .standard(proto: "app_state_bytes"),
    ]

    fileprivate class _StorageClass {
        var _time: SwiftProtobuf.Google_Protobuf_Timestamp?
        var _chainID: String = String()
        var _consensusParams: Types_ConsensusParams?
        var _validators: [Types_ValidatorUpdate] = []
        var _appStateBytes: Data = SwiftProtobuf.Internal.emptyData

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _time = source._time
            _chainID = source._chainID
            _consensusParams = source._consensusParams
            _validators = source._validators
            _appStateBytes = source._appStateBytes
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._time)
                case 2: try decoder.decodeSingularStringField(value: &_storage._chainID)
                case 3: try decoder.decodeSingularMessageField(value: &_storage._consensusParams)
                case 4: try decoder.decodeRepeatedMessageField(value: &_storage._validators)
                case 5: try decoder.decodeSingularBytesField(value: &_storage._appStateBytes)
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if let v = _storage._time {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }
            if !_storage._chainID.isEmpty {
                try visitor.visitSingularStringField(value: _storage._chainID, fieldNumber: 2)
            }
            if let v = _storage._consensusParams {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }
            if !_storage._validators.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._validators, fieldNumber: 4)
            }
            if !_storage._appStateBytes.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._appStateBytes, fieldNumber: 5)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_RequestInitChain, rhs: Types_RequestInitChain) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._time != rhs_storage._time { return false }
                if _storage._chainID != rhs_storage._chainID { return false }
                if _storage._consensusParams != rhs_storage._consensusParams { return false }
                if _storage._validators != rhs_storage._validators { return false }
                if _storage._appStateBytes != rhs_storage._appStateBytes { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_RequestQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RequestQuery"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "data"),
        2: .same(proto: "path"),
        3: .same(proto: "height"),
        4: .same(proto: "prove"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &data)
            case 2: try decoder.decodeSingularStringField(value: &path)
            case 3: try decoder.decodeSingularInt64Field(value: &height)
            case 4: try decoder.decodeSingularBoolField(value: &prove)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 1)
        }
        if !path.isEmpty {
            try visitor.visitSingularStringField(value: path, fieldNumber: 2)
        }
        if height != 0 {
            try visitor.visitSingularInt64Field(value: height, fieldNumber: 3)
        }
        if prove != false {
            try visitor.visitSingularBoolField(value: prove, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_RequestQuery, rhs: Types_RequestQuery) -> Bool {
        if lhs.data != rhs.data { return false }
        if lhs.path != rhs.path { return false }
        if lhs.height != rhs.height { return false }
        if lhs.prove != rhs.prove { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_RequestBeginBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RequestBeginBlock"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "hash"),
        2: .same(proto: "header"),
        3: .standard(proto: "last_commit_info"),
        4: .standard(proto: "byzantine_validators"),
    ]

    fileprivate class _StorageClass {
        var _hash: Data = SwiftProtobuf.Internal.emptyData
        var _header: Types_Header?
        var _lastCommitInfo: Types_LastCommitInfo?
        var _byzantineValidators: [Types_Evidence] = []

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _hash = source._hash
            _header = source._header
            _lastCommitInfo = source._lastCommitInfo
            _byzantineValidators = source._byzantineValidators
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeSingularBytesField(value: &_storage._hash)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._header)
                case 3: try decoder.decodeSingularMessageField(value: &_storage._lastCommitInfo)
                case 4: try decoder.decodeRepeatedMessageField(value: &_storage._byzantineValidators)
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if !_storage._hash.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._hash, fieldNumber: 1)
            }
            if let v = _storage._header {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }
            if let v = _storage._lastCommitInfo {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }
            if !_storage._byzantineValidators.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._byzantineValidators, fieldNumber: 4)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_RequestBeginBlock, rhs: Types_RequestBeginBlock) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._hash != rhs_storage._hash { return false }
                if _storage._header != rhs_storage._header { return false }
                if _storage._lastCommitInfo != rhs_storage._lastCommitInfo { return false }
                if _storage._byzantineValidators != rhs_storage._byzantineValidators { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_RequestCheckTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RequestCheckTx"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "tx"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &tx)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !tx.isEmpty {
            try visitor.visitSingularBytesField(value: tx, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_RequestCheckTx, rhs: Types_RequestCheckTx) -> Bool {
        if lhs.tx != rhs.tx { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_RequestDeliverTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RequestDeliverTx"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "tx"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &tx)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !tx.isEmpty {
            try visitor.visitSingularBytesField(value: tx, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_RequestDeliverTx, rhs: Types_RequestDeliverTx) -> Bool {
        if lhs.tx != rhs.tx { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_RequestEndBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RequestEndBlock"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "height"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &height)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if height != 0 {
            try visitor.visitSingularInt64Field(value: height, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_RequestEndBlock, rhs: Types_RequestEndBlock) -> Bool {
        if lhs.height != rhs.height { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_RequestCommit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RequestCommit"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_RequestCommit, rhs: Types_RequestCommit) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Response"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "exception"),
        2: .same(proto: "echo"),
        3: .same(proto: "flush"),
        4: .same(proto: "info"),
        5: .standard(proto: "set_option"),
        6: .standard(proto: "init_chain"),
        7: .same(proto: "query"),
        8: .standard(proto: "begin_block"),
        9: .standard(proto: "check_tx"),
        10: .standard(proto: "deliver_tx"),
        11: .standard(proto: "end_block"),
        12: .same(proto: "commit"),
    ]

    fileprivate class _StorageClass {
        var _value: Types_Response.OneOf_Value?

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _value = source._value
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1:
                    var v: Types_ResponseException?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .exception(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .exception(v) }
                case 2:
                    var v: Types_ResponseEcho?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .echo(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .echo(v) }
                case 3:
                    var v: Types_ResponseFlush?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .flush(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .flush(v) }
                case 4:
                    var v: Types_ResponseInfo?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .info(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .info(v) }
                case 5:
                    var v: Types_ResponseSetOption?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .setOption(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .setOption(v) }
                case 6:
                    var v: Types_ResponseInitChain?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .initChain(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .initChain(v) }
                case 7:
                    var v: Types_ResponseQuery?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .query(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .query(v) }
                case 8:
                    var v: Types_ResponseBeginBlock?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .beginBlock(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .beginBlock(v) }
                case 9:
                    var v: Types_ResponseCheckTx?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .checkTx(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .checkTx(v) }
                case 10:
                    var v: Types_ResponseDeliverTx?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .deliverTx(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .deliverTx(v) }
                case 11:
                    var v: Types_ResponseEndBlock?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .endBlock(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .endBlock(v) }
                case 12:
                    var v: Types_ResponseCommit?
                    if let current = _storage._value {
                        try decoder.handleConflictingOneOf()
                        if case let .commit(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._value = .commit(v) }
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            switch _storage._value {
            case let .exception(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            case let .echo(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            case let .flush(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            case let .info(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            case let .setOption(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            case let .initChain(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            case let .query(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            case let .beginBlock(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            case let .checkTx(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            case let .deliverTx(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            case let .endBlock(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            case let .commit(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_Response, rhs: Types_Response) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._value != rhs_storage._value { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ResponseException: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResponseException"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "error"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &error)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ResponseException, rhs: Types_ResponseException) -> Bool {
        if lhs.error != rhs.error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ResponseEcho: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResponseEcho"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "message"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &message)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ResponseEcho, rhs: Types_ResponseEcho) -> Bool {
        if lhs.message != rhs.message { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ResponseFlush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResponseFlush"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ResponseFlush, rhs: Types_ResponseFlush) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ResponseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResponseInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "data"),
        2: .same(proto: "version"),
        3: .standard(proto: "app_version"),
        4: .standard(proto: "last_block_height"),
        5: .standard(proto: "last_block_app_hash"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &data)
            case 2: try decoder.decodeSingularStringField(value: &version)
            case 3: try decoder.decodeSingularUInt64Field(value: &appVersion)
            case 4: try decoder.decodeSingularInt64Field(value: &lastBlockHeight)
            case 5: try decoder.decodeSingularBytesField(value: &lastBlockAppHash)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !data.isEmpty {
            try visitor.visitSingularStringField(value: data, fieldNumber: 1)
        }
        if !version.isEmpty {
            try visitor.visitSingularStringField(value: version, fieldNumber: 2)
        }
        if appVersion != 0 {
            try visitor.visitSingularUInt64Field(value: appVersion, fieldNumber: 3)
        }
        if lastBlockHeight != 0 {
            try visitor.visitSingularInt64Field(value: lastBlockHeight, fieldNumber: 4)
        }
        if !lastBlockAppHash.isEmpty {
            try visitor.visitSingularBytesField(value: lastBlockAppHash, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ResponseInfo, rhs: Types_ResponseInfo) -> Bool {
        if lhs.data != rhs.data { return false }
        if lhs.version != rhs.version { return false }
        if lhs.appVersion != rhs.appVersion { return false }
        if lhs.lastBlockHeight != rhs.lastBlockHeight { return false }
        if lhs.lastBlockAppHash != rhs.lastBlockAppHash { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ResponseSetOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResponseSetOption"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "code"),
        3: .same(proto: "log"),
        4: .same(proto: "info"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &code)
            case 3: try decoder.decodeSingularStringField(value: &log)
            case 4: try decoder.decodeSingularStringField(value: &info)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if code != 0 {
            try visitor.visitSingularUInt32Field(value: code, fieldNumber: 1)
        }
        if !log.isEmpty {
            try visitor.visitSingularStringField(value: log, fieldNumber: 3)
        }
        if !info.isEmpty {
            try visitor.visitSingularStringField(value: info, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ResponseSetOption, rhs: Types_ResponseSetOption) -> Bool {
        if lhs.code != rhs.code { return false }
        if lhs.log != rhs.log { return false }
        if lhs.info != rhs.info { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ResponseInitChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResponseInitChain"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "consensus_params"),
        2: .same(proto: "validators"),
    ]

    fileprivate class _StorageClass {
        var _consensusParams: Types_ConsensusParams?
        var _validators: [Types_ValidatorUpdate] = []

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _consensusParams = source._consensusParams
            _validators = source._validators
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._consensusParams)
                case 2: try decoder.decodeRepeatedMessageField(value: &_storage._validators)
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if let v = _storage._consensusParams {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }
            if !_storage._validators.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._validators, fieldNumber: 2)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ResponseInitChain, rhs: Types_ResponseInitChain) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._consensusParams != rhs_storage._consensusParams { return false }
                if _storage._validators != rhs_storage._validators { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ResponseQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResponseQuery"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "code"),
        3: .same(proto: "log"),
        4: .same(proto: "info"),
        5: .same(proto: "index"),
        6: .same(proto: "key"),
        7: .same(proto: "value"),
        8: .same(proto: "proof"),
        9: .same(proto: "height"),
        10: .same(proto: "codespace"),
    ]

    fileprivate class _StorageClass {
        var _code: UInt32 = 0
        var _log: String = String()
        var _info: String = String()
        var _index: Int64 = 0
        var _key: Data = SwiftProtobuf.Internal.emptyData
        var _value: Data = SwiftProtobuf.Internal.emptyData
        var _proof: Merkle_Proof?
        var _height: Int64 = 0
        var _codespace: String = String()

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _code = source._code
            _log = source._log
            _info = source._info
            _index = source._index
            _key = source._key
            _value = source._value
            _proof = source._proof
            _height = source._height
            _codespace = source._codespace
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeSingularUInt32Field(value: &_storage._code)
                case 3: try decoder.decodeSingularStringField(value: &_storage._log)
                case 4: try decoder.decodeSingularStringField(value: &_storage._info)
                case 5: try decoder.decodeSingularInt64Field(value: &_storage._index)
                case 6: try decoder.decodeSingularBytesField(value: &_storage._key)
                case 7: try decoder.decodeSingularBytesField(value: &_storage._value)
                case 8: try decoder.decodeSingularMessageField(value: &_storage._proof)
                case 9: try decoder.decodeSingularInt64Field(value: &_storage._height)
                case 10: try decoder.decodeSingularStringField(value: &_storage._codespace)
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if _storage._code != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._code, fieldNumber: 1)
            }
            if !_storage._log.isEmpty {
                try visitor.visitSingularStringField(value: _storage._log, fieldNumber: 3)
            }
            if !_storage._info.isEmpty {
                try visitor.visitSingularStringField(value: _storage._info, fieldNumber: 4)
            }
            if _storage._index != 0 {
                try visitor.visitSingularInt64Field(value: _storage._index, fieldNumber: 5)
            }
            if !_storage._key.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._key, fieldNumber: 6)
            }
            if !_storage._value.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._value, fieldNumber: 7)
            }
            if let v = _storage._proof {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            }
            if _storage._height != 0 {
                try visitor.visitSingularInt64Field(value: _storage._height, fieldNumber: 9)
            }
            if !_storage._codespace.isEmpty {
                try visitor.visitSingularStringField(value: _storage._codespace, fieldNumber: 10)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ResponseQuery, rhs: Types_ResponseQuery) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._code != rhs_storage._code { return false }
                if _storage._log != rhs_storage._log { return false }
                if _storage._info != rhs_storage._info { return false }
                if _storage._index != rhs_storage._index { return false }
                if _storage._key != rhs_storage._key { return false }
                if _storage._value != rhs_storage._value { return false }
                if _storage._proof != rhs_storage._proof { return false }
                if _storage._height != rhs_storage._height { return false }
                if _storage._codespace != rhs_storage._codespace { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ResponseBeginBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResponseBeginBlock"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "events"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &events)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !events.isEmpty {
            try visitor.visitRepeatedMessageField(value: events, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ResponseBeginBlock, rhs: Types_ResponseBeginBlock) -> Bool {
        if lhs.events != rhs.events { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ResponseCheckTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResponseCheckTx"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "code"),
        2: .same(proto: "data"),
        3: .same(proto: "log"),
        4: .same(proto: "info"),
        5: .standard(proto: "gas_wanted"),
        6: .standard(proto: "gas_used"),
        7: .same(proto: "events"),
        8: .same(proto: "codespace"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &code)
            case 2: try decoder.decodeSingularBytesField(value: &data)
            case 3: try decoder.decodeSingularStringField(value: &log)
            case 4: try decoder.decodeSingularStringField(value: &info)
            case 5: try decoder.decodeSingularInt64Field(value: &gasWanted)
            case 6: try decoder.decodeSingularInt64Field(value: &gasUsed)
            case 7: try decoder.decodeRepeatedMessageField(value: &events)
            case 8: try decoder.decodeSingularStringField(value: &codespace)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if code != 0 {
            try visitor.visitSingularUInt32Field(value: code, fieldNumber: 1)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 2)
        }
        if !log.isEmpty {
            try visitor.visitSingularStringField(value: log, fieldNumber: 3)
        }
        if !info.isEmpty {
            try visitor.visitSingularStringField(value: info, fieldNumber: 4)
        }
        if gasWanted != 0 {
            try visitor.visitSingularInt64Field(value: gasWanted, fieldNumber: 5)
        }
        if gasUsed != 0 {
            try visitor.visitSingularInt64Field(value: gasUsed, fieldNumber: 6)
        }
        if !events.isEmpty {
            try visitor.visitRepeatedMessageField(value: events, fieldNumber: 7)
        }
        if !codespace.isEmpty {
            try visitor.visitSingularStringField(value: codespace, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ResponseCheckTx, rhs: Types_ResponseCheckTx) -> Bool {
        if lhs.code != rhs.code { return false }
        if lhs.data != rhs.data { return false }
        if lhs.log != rhs.log { return false }
        if lhs.info != rhs.info { return false }
        if lhs.gasWanted != rhs.gasWanted { return false }
        if lhs.gasUsed != rhs.gasUsed { return false }
        if lhs.events != rhs.events { return false }
        if lhs.codespace != rhs.codespace { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ResponseDeliverTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResponseDeliverTx"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "code"),
        2: .same(proto: "data"),
        3: .same(proto: "log"),
        4: .same(proto: "info"),
        5: .standard(proto: "gas_wanted"),
        6: .standard(proto: "gas_used"),
        7: .same(proto: "events"),
        8: .same(proto: "codespace"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &code)
            case 2: try decoder.decodeSingularBytesField(value: &data)
            case 3: try decoder.decodeSingularStringField(value: &log)
            case 4: try decoder.decodeSingularStringField(value: &info)
            case 5: try decoder.decodeSingularInt64Field(value: &gasWanted)
            case 6: try decoder.decodeSingularInt64Field(value: &gasUsed)
            case 7: try decoder.decodeRepeatedMessageField(value: &events)
            case 8: try decoder.decodeSingularStringField(value: &codespace)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if code != 0 {
            try visitor.visitSingularUInt32Field(value: code, fieldNumber: 1)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 2)
        }
        if !log.isEmpty {
            try visitor.visitSingularStringField(value: log, fieldNumber: 3)
        }
        if !info.isEmpty {
            try visitor.visitSingularStringField(value: info, fieldNumber: 4)
        }
        if gasWanted != 0 {
            try visitor.visitSingularInt64Field(value: gasWanted, fieldNumber: 5)
        }
        if gasUsed != 0 {
            try visitor.visitSingularInt64Field(value: gasUsed, fieldNumber: 6)
        }
        if !events.isEmpty {
            try visitor.visitRepeatedMessageField(value: events, fieldNumber: 7)
        }
        if !codespace.isEmpty {
            try visitor.visitSingularStringField(value: codespace, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ResponseDeliverTx, rhs: Types_ResponseDeliverTx) -> Bool {
        if lhs.code != rhs.code { return false }
        if lhs.data != rhs.data { return false }
        if lhs.log != rhs.log { return false }
        if lhs.info != rhs.info { return false }
        if lhs.gasWanted != rhs.gasWanted { return false }
        if lhs.gasUsed != rhs.gasUsed { return false }
        if lhs.events != rhs.events { return false }
        if lhs.codespace != rhs.codespace { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ResponseEndBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResponseEndBlock"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "validator_updates"),
        2: .standard(proto: "consensus_param_updates"),
        3: .same(proto: "events"),
    ]

    fileprivate class _StorageClass {
        var _validatorUpdates: [Types_ValidatorUpdate] = []
        var _consensusParamUpdates: Types_ConsensusParams?
        var _events: [Types_Event] = []

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _validatorUpdates = source._validatorUpdates
            _consensusParamUpdates = source._consensusParamUpdates
            _events = source._events
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeRepeatedMessageField(value: &_storage._validatorUpdates)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._consensusParamUpdates)
                case 3: try decoder.decodeRepeatedMessageField(value: &_storage._events)
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if !_storage._validatorUpdates.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._validatorUpdates, fieldNumber: 1)
            }
            if let v = _storage._consensusParamUpdates {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }
            if !_storage._events.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._events, fieldNumber: 3)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ResponseEndBlock, rhs: Types_ResponseEndBlock) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._validatorUpdates != rhs_storage._validatorUpdates { return false }
                if _storage._consensusParamUpdates != rhs_storage._consensusParamUpdates { return false }
                if _storage._events != rhs_storage._events { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ResponseCommit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResponseCommit"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        2: .same(proto: "data"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 2: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ResponseCommit, rhs: Types_ResponseCommit) -> Bool {
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ConsensusParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ConsensusParams"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "block"),
        2: .same(proto: "evidence"),
        3: .same(proto: "validator"),
    ]

    fileprivate class _StorageClass {
        var _block: Types_BlockParams?
        var _evidence: Types_EvidenceParams?
        var _validator: Types_ValidatorParams?

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _block = source._block
            _evidence = source._evidence
            _validator = source._validator
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._block)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._evidence)
                case 3: try decoder.decodeSingularMessageField(value: &_storage._validator)
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if let v = _storage._block {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }
            if let v = _storage._evidence {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }
            if let v = _storage._validator {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ConsensusParams, rhs: Types_ConsensusParams) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._block != rhs_storage._block { return false }
                if _storage._evidence != rhs_storage._evidence { return false }
                if _storage._validator != rhs_storage._validator { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_BlockParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".BlockParams"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "max_bytes"),
        2: .standard(proto: "max_gas"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &maxBytes)
            case 2: try decoder.decodeSingularInt64Field(value: &maxGas)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if maxBytes != 0 {
            try visitor.visitSingularInt64Field(value: maxBytes, fieldNumber: 1)
        }
        if maxGas != 0 {
            try visitor.visitSingularInt64Field(value: maxGas, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_BlockParams, rhs: Types_BlockParams) -> Bool {
        if lhs.maxBytes != rhs.maxBytes { return false }
        if lhs.maxGas != rhs.maxGas { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_EvidenceParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".EvidenceParams"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "max_age"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &maxAge)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if maxAge != 0 {
            try visitor.visitSingularInt64Field(value: maxAge, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_EvidenceParams, rhs: Types_EvidenceParams) -> Bool {
        if lhs.maxAge != rhs.maxAge { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ValidatorParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ValidatorParams"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pub_key_types"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedStringField(value: &pubKeyTypes)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !pubKeyTypes.isEmpty {
            try visitor.visitRepeatedStringField(value: pubKeyTypes, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ValidatorParams, rhs: Types_ValidatorParams) -> Bool {
        if lhs.pubKeyTypes != rhs.pubKeyTypes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_LastCommitInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LastCommitInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "round"),
        2: .same(proto: "votes"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt32Field(value: &round)
            case 2: try decoder.decodeRepeatedMessageField(value: &votes)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if round != 0 {
            try visitor.visitSingularInt32Field(value: round, fieldNumber: 1)
        }
        if !votes.isEmpty {
            try visitor.visitRepeatedMessageField(value: votes, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_LastCommitInfo, rhs: Types_LastCommitInfo) -> Bool {
        if lhs.round != rhs.round { return false }
        if lhs.votes != rhs.votes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Event"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "attributes"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &type)
            case 2: try decoder.decodeRepeatedMessageField(value: &attributes)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        if !attributes.isEmpty {
            try visitor.visitRepeatedMessageField(value: attributes, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_Event, rhs: Types_Event) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.attributes != rhs.attributes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Header"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "version"),
        2: .standard(proto: "chain_id"),
        3: .same(proto: "height"),
        4: .same(proto: "time"),
        5: .standard(proto: "num_txs"),
        6: .standard(proto: "total_txs"),
        7: .standard(proto: "last_block_id"),
        8: .standard(proto: "last_commit_hash"),
        9: .standard(proto: "data_hash"),
        10: .standard(proto: "validators_hash"),
        11: .standard(proto: "next_validators_hash"),
        12: .standard(proto: "consensus_hash"),
        13: .standard(proto: "app_hash"),
        14: .standard(proto: "last_results_hash"),
        15: .standard(proto: "evidence_hash"),
        16: .standard(proto: "proposer_address"),
    ]

    fileprivate class _StorageClass {
        var _version: Types_Version?
        var _chainID: String = String()
        var _height: Int64 = 0
        var _time: SwiftProtobuf.Google_Protobuf_Timestamp?
        var _numTxs: Int64 = 0
        var _totalTxs: Int64 = 0
        var _lastBlockID: Types_BlockID?
        var _lastCommitHash: Data = SwiftProtobuf.Internal.emptyData
        var _dataHash: Data = SwiftProtobuf.Internal.emptyData
        var _validatorsHash: Data = SwiftProtobuf.Internal.emptyData
        var _nextValidatorsHash: Data = SwiftProtobuf.Internal.emptyData
        var _consensusHash: Data = SwiftProtobuf.Internal.emptyData
        var _appHash: Data = SwiftProtobuf.Internal.emptyData
        var _lastResultsHash: Data = SwiftProtobuf.Internal.emptyData
        var _evidenceHash: Data = SwiftProtobuf.Internal.emptyData
        var _proposerAddress: Data = SwiftProtobuf.Internal.emptyData

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _version = source._version
            _chainID = source._chainID
            _height = source._height
            _time = source._time
            _numTxs = source._numTxs
            _totalTxs = source._totalTxs
            _lastBlockID = source._lastBlockID
            _lastCommitHash = source._lastCommitHash
            _dataHash = source._dataHash
            _validatorsHash = source._validatorsHash
            _nextValidatorsHash = source._nextValidatorsHash
            _consensusHash = source._consensusHash
            _appHash = source._appHash
            _lastResultsHash = source._lastResultsHash
            _evidenceHash = source._evidenceHash
            _proposerAddress = source._proposerAddress
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._version)
                case 2: try decoder.decodeSingularStringField(value: &_storage._chainID)
                case 3: try decoder.decodeSingularInt64Field(value: &_storage._height)
                case 4: try decoder.decodeSingularMessageField(value: &_storage._time)
                case 5: try decoder.decodeSingularInt64Field(value: &_storage._numTxs)
                case 6: try decoder.decodeSingularInt64Field(value: &_storage._totalTxs)
                case 7: try decoder.decodeSingularMessageField(value: &_storage._lastBlockID)
                case 8: try decoder.decodeSingularBytesField(value: &_storage._lastCommitHash)
                case 9: try decoder.decodeSingularBytesField(value: &_storage._dataHash)
                case 10: try decoder.decodeSingularBytesField(value: &_storage._validatorsHash)
                case 11: try decoder.decodeSingularBytesField(value: &_storage._nextValidatorsHash)
                case 12: try decoder.decodeSingularBytesField(value: &_storage._consensusHash)
                case 13: try decoder.decodeSingularBytesField(value: &_storage._appHash)
                case 14: try decoder.decodeSingularBytesField(value: &_storage._lastResultsHash)
                case 15: try decoder.decodeSingularBytesField(value: &_storage._evidenceHash)
                case 16: try decoder.decodeSingularBytesField(value: &_storage._proposerAddress)
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if let v = _storage._version {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }
            if !_storage._chainID.isEmpty {
                try visitor.visitSingularStringField(value: _storage._chainID, fieldNumber: 2)
            }
            if _storage._height != 0 {
                try visitor.visitSingularInt64Field(value: _storage._height, fieldNumber: 3)
            }
            if let v = _storage._time {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }
            if _storage._numTxs != 0 {
                try visitor.visitSingularInt64Field(value: _storage._numTxs, fieldNumber: 5)
            }
            if _storage._totalTxs != 0 {
                try visitor.visitSingularInt64Field(value: _storage._totalTxs, fieldNumber: 6)
            }
            if let v = _storage._lastBlockID {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }
            if !_storage._lastCommitHash.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._lastCommitHash, fieldNumber: 8)
            }
            if !_storage._dataHash.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._dataHash, fieldNumber: 9)
            }
            if !_storage._validatorsHash.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._validatorsHash, fieldNumber: 10)
            }
            if !_storage._nextValidatorsHash.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._nextValidatorsHash, fieldNumber: 11)
            }
            if !_storage._consensusHash.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._consensusHash, fieldNumber: 12)
            }
            if !_storage._appHash.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._appHash, fieldNumber: 13)
            }
            if !_storage._lastResultsHash.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._lastResultsHash, fieldNumber: 14)
            }
            if !_storage._evidenceHash.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._evidenceHash, fieldNumber: 15)
            }
            if !_storage._proposerAddress.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._proposerAddress, fieldNumber: 16)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_Header, rhs: Types_Header) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._version != rhs_storage._version { return false }
                if _storage._chainID != rhs_storage._chainID { return false }
                if _storage._height != rhs_storage._height { return false }
                if _storage._time != rhs_storage._time { return false }
                if _storage._numTxs != rhs_storage._numTxs { return false }
                if _storage._totalTxs != rhs_storage._totalTxs { return false }
                if _storage._lastBlockID != rhs_storage._lastBlockID { return false }
                if _storage._lastCommitHash != rhs_storage._lastCommitHash { return false }
                if _storage._dataHash != rhs_storage._dataHash { return false }
                if _storage._validatorsHash != rhs_storage._validatorsHash { return false }
                if _storage._nextValidatorsHash != rhs_storage._nextValidatorsHash { return false }
                if _storage._consensusHash != rhs_storage._consensusHash { return false }
                if _storage._appHash != rhs_storage._appHash { return false }
                if _storage._lastResultsHash != rhs_storage._lastResultsHash { return false }
                if _storage._evidenceHash != rhs_storage._evidenceHash { return false }
                if _storage._proposerAddress != rhs_storage._proposerAddress { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_Version: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Version"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "Block"),
        2: .same(proto: "App"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &block)
            case 2: try decoder.decodeSingularUInt64Field(value: &app)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if block != 0 {
            try visitor.visitSingularUInt64Field(value: block, fieldNumber: 1)
        }
        if app != 0 {
            try visitor.visitSingularUInt64Field(value: app, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_Version, rhs: Types_Version) -> Bool {
        if lhs.block != rhs.block { return false }
        if lhs.app != rhs.app { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_BlockID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".BlockID"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "hash"),
        2: .standard(proto: "parts_header"),
    ]

    fileprivate class _StorageClass {
        var _hash: Data = SwiftProtobuf.Internal.emptyData
        var _partsHeader: Types_PartSetHeader?

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _hash = source._hash
            _partsHeader = source._partsHeader
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeSingularBytesField(value: &_storage._hash)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._partsHeader)
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if !_storage._hash.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._hash, fieldNumber: 1)
            }
            if let v = _storage._partsHeader {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_BlockID, rhs: Types_BlockID) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._hash != rhs_storage._hash { return false }
                if _storage._partsHeader != rhs_storage._partsHeader { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_PartSetHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PartSetHeader"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "total"),
        2: .same(proto: "hash"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt32Field(value: &total)
            case 2: try decoder.decodeSingularBytesField(value: &hash)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if total != 0 {
            try visitor.visitSingularInt32Field(value: total, fieldNumber: 1)
        }
        if !hash.isEmpty {
            try visitor.visitSingularBytesField(value: hash, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_PartSetHeader, rhs: Types_PartSetHeader) -> Bool {
        if lhs.total != rhs.total { return false }
        if lhs.hash != rhs.hash { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Validator"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        3: .same(proto: "power"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &address)
            case 3: try decoder.decodeSingularInt64Field(value: &power)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !address.isEmpty {
            try visitor.visitSingularBytesField(value: address, fieldNumber: 1)
        }
        if power != 0 {
            try visitor.visitSingularInt64Field(value: power, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_Validator, rhs: Types_Validator) -> Bool {
        if lhs.address != rhs.address { return false }
        if lhs.power != rhs.power { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_ValidatorUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ValidatorUpdate"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pub_key"),
        2: .same(proto: "power"),
    ]

    fileprivate class _StorageClass {
        var _pubKey: Types_PubKey?
        var _power: Int64 = 0

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _pubKey = source._pubKey
            _power = source._power
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._pubKey)
                case 2: try decoder.decodeSingularInt64Field(value: &_storage._power)
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if let v = _storage._pubKey {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }
            if _storage._power != 0 {
                try visitor.visitSingularInt64Field(value: _storage._power, fieldNumber: 2)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_ValidatorUpdate, rhs: Types_ValidatorUpdate) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._pubKey != rhs_storage._pubKey { return false }
                if _storage._power != rhs_storage._power { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_VoteInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VoteInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "validator"),
        2: .standard(proto: "signed_last_block"),
    ]

    fileprivate class _StorageClass {
        var _validator: Types_Validator?
        var _signedLastBlock: Bool = false

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _validator = source._validator
            _signedLastBlock = source._signedLastBlock
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._validator)
                case 2: try decoder.decodeSingularBoolField(value: &_storage._signedLastBlock)
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if let v = _storage._validator {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }
            if _storage._signedLastBlock != false {
                try visitor.visitSingularBoolField(value: _storage._signedLastBlock, fieldNumber: 2)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_VoteInfo, rhs: Types_VoteInfo) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._validator != rhs_storage._validator { return false }
                if _storage._signedLastBlock != rhs_storage._signedLastBlock { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_PubKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PubKey"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "data"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &type)
            case 2: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_PubKey, rhs: Types_PubKey) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Types_Evidence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Evidence"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "validator"),
        3: .same(proto: "height"),
        4: .same(proto: "time"),
        5: .standard(proto: "total_voting_power"),
    ]

    fileprivate class _StorageClass {
        var _type: String = String()
        var _validator: Types_Validator?
        var _height: Int64 = 0
        var _time: SwiftProtobuf.Google_Protobuf_Timestamp?
        var _totalVotingPower: Int64 = 0

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _type = source._type
            _validator = source._validator
            _height = source._height
            _time = source._time
            _totalVotingPower = source._totalVotingPower
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeSingularStringField(value: &_storage._type)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._validator)
                case 3: try decoder.decodeSingularInt64Field(value: &_storage._height)
                case 4: try decoder.decodeSingularMessageField(value: &_storage._time)
                case 5: try decoder.decodeSingularInt64Field(value: &_storage._totalVotingPower)
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if !_storage._type.isEmpty {
                try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 1)
            }
            if let v = _storage._validator {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }
            if _storage._height != 0 {
                try visitor.visitSingularInt64Field(value: _storage._height, fieldNumber: 3)
            }
            if let v = _storage._time {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }
            if _storage._totalVotingPower != 0 {
                try visitor.visitSingularInt64Field(value: _storage._totalVotingPower, fieldNumber: 5)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Types_Evidence, rhs: Types_Evidence) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._type != rhs_storage._type { return false }
                if _storage._validator != rhs_storage._validator { return false }
                if _storage._height != rhs_storage._height { return false }
                if _storage._time != rhs_storage._time { return false }
                if _storage._totalVotingPower != rhs_storage._totalVotingPower { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
